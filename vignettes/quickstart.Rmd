---
title: "barista: Analysis of synthetic DNA barcodes"
author: "Dane Vassiliadis"
output: 
  rmarkdown::html_document:
    toc: true
    number_sections: true
    toc_depth: 3
    highlight: tango 
date: June 27, 2019
vignette: >
  %\VignetteIndexEntry{barista-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Quickstart Guide

## Introduction

### A brief introduction to DNA barcoding technology
The ability to accurately track the progeny of a clone within a population of cells is necessary to dissect biological phenomena at single cell resolution. Several technologies have emerged that enable lineage tracing in cell populations. Many of these involve the insertion or generation of a unique sequence of DNA that marks the genome of each cell and which can be tracked using high throughput sequencing technologies. These markers are often termed DNA barcodes as they essentially consist of a stretch of degenerate DNA bases which is unique to that cell. This degenerate sequence of bases affords considerable complexity to the barcode library and uniqueness to each barcode. Many current DNA barcoding methodologies utilise stretches of up to 60 bases for their barcode region allowing an astronomical theoretical number of individual barcodes to be generated from combinations of the four nucleotides that comprise DNA: adenine (A), thymine (T), guanine (G) and cytosine (C). In reality, the need to synthesize and clone these barcodes into viral vectors reduces the overall complexity that can be achieved. Nevertheless, several barcode constructs exist with barcode complexities reaching 10^6 unique barcodes or higher.

### What is barista
`barista` was built out of our need to develop robust tools for the analysis of DNA barcoding datasets in a large number of samples. The package consists of a suite of functions to annotate, analyse and plot DNA barcodes that are read out using common high throughput sequencing methodologies such as those obtained from Illumina machines. Furthermore, the rapid rise of single cell technologies has necessitated the development of methods that can process and visualise DNA barcode data at single cell resolution. New methods incorporate barcode sequences into the three prime region of a reporter gene construct that is transcribed under the direction of a constitutive promoter. This results in transcription of the barcode which can be detected in 3 prime single cell RNA sequencing datasets. Recent examples of this are SPLINTR (ref), LARRY (ref) and CellTagging (ref). barista contains additional methods to process and visualise these datatypes with the aim of opening up this technology to the broader scientific community. This vignette will showcase the capabilities of the barista package for processing and analysing synthetic barcode information at the bulk and single cell levels.

## Getting started
The `barista` package is optimised for use with SPLINTR lineage barcode libraries (ref) however the functions within can be adapted to any DNA barcoding methodology that utiilses random DNA barcodes.

### The reference barcode library
In the current version, `barista` assumes that any barcoding experiment uses a known reference library of barcodes. Since DNA barcodes are generally introduced into cells using viral vectors, the plasmid pool used to generate the barcode virus represents the reference set of barcodes that can be present in an experiment. The primary step in any barcoding analysis is to determine what barcodes are present in this reference pool and at what proportion.

In the case of SPLINTR, barcodes take the following form:
```
tgaccatgtacgattgactaNNSWSNNWSWNNSWSNNWSWNNSWSNNWSWNNSWSNNWSWNNSWSNNWSWNNSWSNNWSWtgctaatgcgtactg
```

where lower case sequence represents upstream and downstream constant regions that are critical for accurately retrieving barcodes from the genomic DNA of cells.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Load the barista library 
```{r setup}
library(barista)
```

## A simple analysis
Here we will follow the analysis of an example experiment to understand the basic functions of barista. Say we have a population of cells growing in culture. These cells were transduced with a lentiviral vector encoding an mCHERRY fluorescent protein and a downstream barcode in the 3' UTR possessing the following structure:

```
tgaccatgtacgattgactaNNSWSNNWSWNNSWSNNWSWNNSWSNNWSWNNSWSNNWSWNNSWSNNWSWNNSWSNNWSWtgctaatgcgtactg
```

Two days after transduction, two sets of 5000 mCHERRY positive cells were sorted using flow cytometry into separate wells and resuspended in culture media. Genomic DNA from the cells was harvested 1 week following transduction and barcode regions were specifically amplified using PCR and sequenced for 75 cycles on an Illumina NextSeq 550 resulting in single ended fastq files containing barcoded reads. 

### barcode pre-processing
Barcode information can be extracted from raw fastq files and summarised into a table of counts per barcode as follows

Firstly we define the expected barcode pattern and the upstream and downstream constant regions that flank true barcodes. And then extract reads containing this barcode pattern using the `extractbaristaeads` function
```{r}
pattern <- "([ACTG][ACTG][GC][AT][GC][ACTG][ACTG][AT][GC][AT]){3,6}"
fastq <- system.file("extdata", "test_extract_75bp_single-end.fastq.gz", package = "barista", mustWork = T)
constant <- toupper("tgaccatgtacgattgacta")
test.extract <- barista::extractbaristaeads(infile = fastq, 
                              barcode_pattern = pattern,
                              constant = constant, 
                              yieldSize = 1e6)
test.extract
```

Following barcode extraction we make use of previously generated library of reference barcodes and map our extracted sequences to this reference using `mapbaristaeads`. True barcodes will align without mismatches. reads containing sequencing errors or false barcode sequences that snuck through the extraction step will be filtered out here. 
```{r}
test.map <- barista::mapbaristaeads(reads = test.extract,
                                      bowtie_index = "../data/bowtie/index",
                                      mismatches = 1,
                                      threads = 1,
                                      prefix = "test_map")
test.map

```

If a bowtie reference has not yet been generated we can specify `reference_fasta` in place of `bowtie_index` and it will be generated for us
```{r}
reference.fa <- system.file("extdata", "barcode_lib_reference_test.fasta", package = "barista", mustWork = T)
test.map <- barista::mapBarcodeReads(reads = test.extract,
                                      bowtie_index = NULL,
                                      reference_fasta = reference.fa,
                                      mismatches = 1,
                                      threads = 2,
                                      prefix = "test_map")
test.map
```

`mapBarcodeReads` takes the liberty of counting the number of occurrences of each barcode for us and saving the output in a file. 
We can easily load and examine the final count data here.
```{r}
test.counts <- utils::read.delim("./test_map_counts.csv", header = T, sep = ",", row.names = 1)
test.counts %>% tibble::rownames_to_column() %>% dplyr::arrange(dplyr::desc(mapped))
```

### Alternative pre-processing workflow using BARtab
For large numbers of samples it can be cumbersome and time consuming to process raw count data within R as shown above. It is more efficient to process these samples and generate count tables using a pipeline that can be distributed across HPC infrastructure

We have developed BARtab, a Nextflow (ref) pipeline for the preprocessing of DNA barcoding datasets from bulk and single-cell experiments. 
The pipeline and associated running instructions can be found at `<insert link to barcode-seq pipeline>`  

```{bash}
# ToDo
# example running snakemake barcode-seq workflow

```


## Importing DNA barcode count data 
Raw barcode count data can be thought of similarly to raw integer-based count data from other count based experiments such as RNA-sequencing. For these data types the `edgeR` package provides an efficient `DGEList` object structure to store sample counts and associated metadata. `barista` makes use of this object structure to store and process DNA barcode counts. 

### A real world example barcoding experiment
For this section we will make use of a DNA barcoding dataset generated in a recent study (Bell and Fennell et al. Nat Comms, 2019) that investigated the clonal diversity within populations of acute myeloid leukaemia (AML) cells cultured in the presence or absence of the BET bromodomain inhibitor IBET-151. 

AML cells were cultured in vitro, barcoded using a lentiviral based barcoding library `reference SPLINTR paper here`, and treated with weekly increasing doses of IBET-151 or a corresponding vehicle control. Barcode samples were sequenced for two biological replicates of this experiment at the baseline timepoint, and at week 1 and week 4, corresponding to the IC40 and IC90 of the drug respectively. 

To follow along with this vignette the raw counts tables and sample metadata can be found at `insert link here to the raw datasets`


### Generating a DGEList object from sample counts and metadata
Counts objects defined above can be specified in a sample metadata sheet as shown below. This is the easiest way to generate a `DGEList` object containing the count information and metadata of interest for a set of barcode sequencing samples. 

```{r}
samplesheet <- read.csv(system.file("extdata", "test_sampletable.csv", package = "barista", mustWork = T), header = T, stringsAsFactors = F)
samplesheet
```

Load in the counts as specified in the samplesheet into a DGEList object
```{r}
library(edgeR)
dge <- edgeR::readDGE(files = samplesheet, group = samplesheet$treatment, labels = samplesheet$sample, header = T)
dge
```


```{r}
dim(dge)
```

## Data QC and Normalisation

### Data QC
We first want to ensure that we are working with clean data. 
We remove barcodes that have no counts across all samples. 
```{r}
# Remove rows with no data
keeprows = rowSums(dge$counts) >= 1
dge.filtered <- dge[keeprows,]
dge.filtered.counts <- dge.filtered$counts
dim(dge.filtered.counts)
```

We then normalise samples to sequencing depth
```{r}
# add library size to metadata
dge.filtered$samples$colSums <- colSums(dge.filtered$counts)

# Normalise each sample to counts per million
dge.cpmnorm <- as.data.frame(cpm(dge.filtered.counts, normalized.lib.sizes = T))
```

We can plot the raw and normalised sequencig depth to get an idea of depth discrepancies between PCR replicates
```{r}
colors <- as.factor(dge.filtered$samples$dose)
barplot(colSums(dge.filtered$counts), las=2, main="Counts per index - Raw counts", col=colors, cex.names=0.8, cex.axis=0.8)
```

```{r}
barplot(colSums(dge.cpmnorm), las=2, main="Counts per index - CPM normalised", col=colors, cex.names=0.8, cex.axis=0.8)
```

For lentiviral based barcoding experiments, such as this one, it is common for the library to exhibit a degree of skewness based on the cloning method. 
This means that some barcodes are represented in the library more than others and so have a greater chance to be transduced into multiple cells.
Most experiments assume that each individual barcode is transduced into only one cell, and that each cell is only transduced with one barcode.This is ensured using a low multiplicity of infection (MOI) transduction in which the likelihood that a cell is transduced with one or more barcode containing virions follows Poisson statistics.
With this in mind, it also can be useful to check the total counts per barcode to identify bias in counts in sample vs. frequency of barcode in reference library.
```{r}
dge.row.sums <- rowSums(dge.filtered$counts)
dge.row.sums.sorted <- sort(dge.row.sums, decreasing = T)
head(dge.row.sums.sorted, 30)

barplot(dge.row.sums, las=2, main="Counts per barcode", axisnames=F, cex.axis=0.8, xlab = "Library Barcode - ordered by reference library frequency", ylab = "Barcode row sum count")
```

In this plot individual barcodes on the x-axis are ordered based on their frequency in the library pool. 
An increased number of counts per barcode toward the left hand side of the plot would be suggestive of transduction bias, meaning that there are more reads for the more abundant barcodes in the library. And so, likely multiple cells were transduced with the same barcode. We dont see this here suggesting that this is not a problem for this analysis. 

### Check correlation between PCR replicates
It is also important to ensure that individual samples are sequenced to an appropriate depth as this ensures that the entire barcode repertoire present in a sample is captured in the data. Sequencing technical duplicates of a sample generated at the library PCR stage is a good way to check this. 

In our experiment we have 9 samples total, each with two PCR technical replicates. 
Here we correlate the barcode distributions for each pair of technical replicates. 

```{r}
# define sample pairs 
dge.filtered$samples$sample <- paste(dge.filtered$samples$dose, dge.filtered$samples$timepoint, dge.filtered$samples$biolrep, sep = "-")
```

We fit a linear model to both technical replicates per sample and plot the regression line. 
Barcodes that are specific to one replicate are highlighted
```{r}
library(ggplot2)
library(ggrepel)

# Plot the linear relationship for each pair of technical replicates
samples <- unique(dge.filtered$samples$sample[1:16])

#lapply(samples, function(x){
#  cols <- which(dge.filtered$samples$sample == as.character(x))
#  data <- as.data.frame(dge.filtered$counts[,cols])
#  fit <- lm(data[,1] ~ data[,2])
#  plotRegression(fit = fit, title = paste("Regression plot:", x)) + 
#    xlab(colnames(data)[1]) + 
#    ylab(colnames(data)[2]) + 
#    geom_label_repel(aes(label=ifelse(data[,1] > 8*sd(data[,1]), as.character(rownames(data)),'')))
#})
```
  
  
### Collapse PCR replicates in object
From this point onward its a good idea to collapse our PCR replicates. 
The result is a clean barcode-seq dataset ready for further investigation and visualisation.
```{r}
dge.filtered.collapsed <- collapseReplicates(dge.filtered, groupby = dge.filtered$samples$sample, by = "mean")
dim(dge.filtered.collapsed)
```

## Visualisation

barista includes a range of visualisation options for examining barcode-seq datasets. 

### Bubble plot
The first of which is 
```{r}

```





